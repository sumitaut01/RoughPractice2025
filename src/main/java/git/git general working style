Branches:

main (or master) = primary branch

feature/login

feature/payment

feature/discount

âœ… THE REAL INDUSTRY WORKFLOW (Merge-based)
ğŸ”¹ Step 1: Developer creates feature branch
git checkout -b feature/login

ğŸ”¹ Step 2: Developer works normally (commit, push, etc.)
D1 â†’ D2 â†’ D3

ğŸ”¹ Step 3: While developing, main gets updated by other developers
main: A â†’ B â†’ C
feature: D1 â†’ D2 â†’ D3

ğŸ”¹ Step 4: Developer syncs latest main INTO their feature branch

This is the correct place to merge â¬‡

git checkout feature/login
git merge main


Now:

main:    A â†’ B â†’ C
feature:      \â†’ D1 â†’ D2 â†’ D3 â†’ M


(M = merge commit)

âœ” Conflict resolved early
âœ” Feature stays updated
âœ” No surprises during PR

ğŸ”¹ Step 5: Developer pushes updated feature branch:
git push

ğŸ”¹ Step 6: Create Pull Request (PR)

Feature branch â†’ main

When PR is approved:

ğŸ”¹ Step 7: Merge feature into main

This creates:

A â†’ B â†’ C â†’ (Merge feature/login) â†’ D1 â†’ D2 â†’ D3

ğŸ”¥ This is the most common workflow.
ğŸ§  So overall merge order looks like this:

You asked:

â€œDo they merge while on feature then merge mainâ€¦ and later merge feature into master?â€

YES â€” EXACTLY THIS:

Work on feature

Merge main â†’ feature (to stay updated)

Push branch

Create PR

Merge feature â†’ main

This is the safest and most used method in the world.



ğŸ¥ˆ 2. Rebase Workflow (Cleaner but riskier)
Used by teams who want clean commit history.
Flow:

Checkout feature
Rebase main â†’ feature
Push force (if never shared!)

PR

Merge feature â†’ main
This produces a clean history (no merge commits).

BUT dangerous if feature branch is already shared with team.

ğŸ”¥ FINAL ANSWER (Sumit Edition ğŸ˜„)
âœ” What devs ideally do?

They regularly pull latest main and merge it into their feature branch.

âœ” Why?

To avoid future conflicts and keep feature branch updated.

âœ” What happens later?

When the feature is ready â†’
They create PR â†’
Branch gets merged back into main.

âœ” The flow is:
feature <-- merge main
feature --> merge to main (via PR)

ğŸ¯ TL;DR:

YES â€” developers work on feature, merge main into feature to stay updated, and finally merge feature into main through PR.










Nice â€” hereâ€™s a compact, practical cheat-sheet + ASCII diagram + commands you can hand to your team. Quick, no-fluff, exactly what people do in real projects.

1) Fast ASCII diagram (merge-based â€” the common way)
main:    A --- B --- C -------------------------------> (main)
                 \                                \
feature:           D --- E --- F --- M  (merge commit) ---> (feature)
                                              \
                                               (PR merged) -> main


Flow:

Create feature from main at commit C

Work: commits D,E,F on feature

Periodically: git merge main into feature â†’ creates merge commit M (resolves conflicts early)

Push feature, open PR â†’ merge feature â†’ main

2) Commands youâ€™ll actually run

Create feature:

git checkout main
git pull origin main
git checkout -b feature/awesome


Work / commit / push:

git add .
git commit -m "WIP: do awesome"
git push -u origin feature/awesome


Keep feature up-to-date (merge main into feature â€” safe):

git checkout feature/awesome
git fetch origin
git merge origin/main        # resolves conflicts on feature branch
git push


Alternative: rebase main onto feature (cleaner history, only if NOT shared):

git checkout feature/awesome
git fetch origin
git rebase origin/main       # rewrites commits D,E,F -> D',E',F'
# fix conflicts, then:
git push --force-with-lease  # only if you are sure branch is private


Open PR â†’ Merge into main (options explained below).

3) How to merge the PR on GitHub (3 options)

Create a merge commit (keeps full history) â€” default in many teams.

Squash and merge (squashes feature commits into single commit) â€” keeps main tidy, loses individual feature commits.

Rebase and merge (replays commits onto main) â€” linear history, but rewrites commit SHAs.

Team pick depends on preference. My recommendation:

Small teams: merge commit or squash.

Libraries / long-term projects: rebase/squash to keep history clean.

4) Best practices / rules to follow

Always sync main into your feature BEFORE opening PR (catch conflicts early).

If you rebase, only rebase branches that are not shared or already reviewed by others.

Use git pull --rebase origin main if you prefer rebase when fetching upstream changes.

Use --force-with-lease instead of --force when pushing rewritten history.

Protect main (require PR, CI checks, required reviewers) â€” prevents accidental force-pushes.

5) Quick decision guide

Want safety + simple team workflow â†’ merge main into feature, then merge PR (merge commit).

Want clean linear history and you work alone on branch â†’ rebase locally, then push (careful).

Want tidy main with one commit per feature â†’ squash merge at PR merge.




Great â€” here is a clean, ready-to-paste, team-friendly â€œGit Workflow Guide (Feature Branch Model)â€ that you can put into your repo as GIT-WORKFLOW.md.

No canvas used unless you want it there â€” just tell me.

ğŸ“˜ GIT WORKFLOW GUIDE (Feature Branch Model)

For teams using main/master as the primary branch

ğŸ§­ Overview

This guide defines how developers should branch, sync, and merge code into main.
It prevents conflicts, ensures clean PRs, and keeps your Git history consistent.

1ï¸âƒ£ Branching Strategy
main (or master)

Always stable

Always deployable

Protected (no direct pushes)

Feature branches

Named as:

feature/<jira-ticket>
feature/<small-summary>


Examples:

feature/LOGIN-142-add-captcha
feature/cart-discount-logic

2ï¸âƒ£ Creating a Feature Branch
git checkout main
git pull origin main
git checkout -b feature/your-branch-name

3ï¸âƒ£ Working on the Feature Branch

Regular workflow:

git add .
git commit -m "Meaningful commit message"
git push -u origin feature/your-branch-name


Push frequently.

4ï¸âƒ£ Keeping Your Feature Branch Updated (VERY IMPORTANT)

While working, main always moves due to other developers.

âœ” Correct way (SAFE): Merge main â†’ feature
git checkout feature/your-branch-name
git fetch origin
git merge origin/main
git push


Resolves conflicts early

Safe for shared branches

NEVER breaks team history

â¡ï¸ This is recommended for most teams.

5ï¸âƒ£ (Optional) Keeping History Clean: Rebase Instead of Merge

âš ï¸ Use only if no one else uses your feature branch.

git checkout feature/your-branch-name
git fetch origin
git rebase origin/main
# resolve conflicts
git add .
git rebase --continue
git push --force-with-lease


Linear history

No merge commits

Requires caution

â¡ï¸ Good for solo developers or small features.

6ï¸âƒ£ Opening a Pull Request (PR)

When feature is ready:

Push your branch

Open PR: feature â†’ main

CI runs tests

Reviewers approve

Resolve comments

7ï¸âƒ£ Merging the PR into Main

Choose one of the following (team standard):

âœ” Option 1 (Recommended): Merge Commit

Keeps full history

No rewriting

Safe for all teams

âœ” Option 2: Squash and Merge

Converts all feature commits â†’ 1 clean commit

Good for keeping main tidy

âœ” Option 3: Rebase and Merge

Linear history in main

Great for clean projects

Should not rebase after PR is opened

8ï¸âƒ£ Deleting the Branch

After merge:

Delete branch on GitHub
git branch -d feature/your-branch-name

9ï¸âƒ£ Quick Decision Guide
Scenario	Recommended Action
Team project	Merge main â†’ feature
Personal feature branch	Rebase main â†’ feature
Branch already shared	NEVER rebase
Want clean main	Use Squash merge
Want full history	Use Merge Commit
ğŸ”Ÿ Common Commands Cheat Sheet
Sync feature with main (safe)
git merge origin/main

Rebase feature onto main (advanced)
git rebase origin/main

Abort rebase
git rebase --abort

Continue rebase after conflict
git add .
git rebase --continue

Push rewritten history safely
git push --force-with-lease

ğŸ Final Visual Summary
main:    A --- B --- C ---- D ---- E ----- F
                 \                    \
feature:          X --- Y --- Z ------- M -----> (PR merged)


Developer works on X, Y, Z

Sometimes merges main â†’ feature (C, D updates)

Eventually PR merges feature â†’ main (M)