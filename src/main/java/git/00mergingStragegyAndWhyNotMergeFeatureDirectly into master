What happens internally in GitHub when you create a PR
How PR merge types work (Merge Commit vs Squash vs Rebase)
Why â€œpulling feature into masterâ€ creates dangerous commit history






Here is the deepest but clearest explanation youâ€™ll ever read â€”
What GitHub does internally, why PRs exist, and why pulling feature â†’ master is dangerous.

Iâ€™ll break it into 3 sections:

ğŸ§© 1. What happens internally in GitHub when you create a Pull Request (PR)

When you create a PR from:

feature/login â†’ main


GitHub performs SEVEN internal operations automatically.

âœ… STEP 1 â€” GitHub compares the two branches

GitHub creates an internal temporary diff:

diff(main, feature)


It finds:

Every commit in feature thatâ€™s not in main

Every line-of-code changed

Renames, deletions, insertions

Merge conflicts (if any)

This becomes the diff view you see.

âœ… STEP 2 â€” CI/CD triggers automatically

GitHub tells your pipeline:

"Run tests on this PR"


CI runs:

build

unit tests

lint/Sonar

integration tests

security checks

Only when ALL PASS â†’ PR becomes green.

âœ… STEP 3 â€” GitHub checks branch protection rules

GitHub checks:

Does main allow direct pushes? (usually no)

Does it require PR? (yes)

Does it require approvals?

Does CI need to pass?

Are review comments resolved?

If any rule is violated â†’
GitHub LOCKS the merge button.

âœ… STEP 4 â€” GitHub attaches metadata

A PR is not just "merge code".
It stores:

Title

Description

Jira link

Author

All commits

All comments

All reviewers

Who approved

Which checks passed

Which files changed

This becomes audit history forever.

âœ… STEP 5 â€” Inline code review system activates

Reviewers can:

Comment on individual lines

Suggest edits

Request changes

Approve changes

GitHub stores all conversations.

âœ… STEP 6 â€” GitHub creates a temporary merge view

Before merging, GitHub simulates:

merged-main = main + feature


It checks:

Is the merge clean?

Are there conflicts?

Does the branch build?

Does CI pass on merged branch?

If conflict exists â†’
GitHub shows â€œThis branch has conflicts that must be resolvedâ€.

âœ… STEP 7 â€” When you press â€œMergeâ€, GitHub does the actual Git operation

Depending on merge type (explained next), GitHub runs:

git merge OR git rebase OR git squash


in the server and updates main.

ğŸ† 2. How PR Merge Types Work (Visually & Internally)

Letâ€™s assume:

MAIN:    A --- B --- C
FEATURE:           \--- D --- E

1ï¸âƒ£ Merge Commit (default, safest)

Command GitHub runs internally:

git checkout main
git merge feature --no-ff


Result:

A --- B --- C ------ M
            \       /
             D --- E


Where M = merge commit.

âœ” Full history
âœ” Easiest to audit
âœ” No rewrite
âœ” Best for teams

2ï¸âƒ£ Squash and Merge

GitHub compresses all feature commits into one commit:

D + E â†’ FEAT-123: Login module complete


Result:

A --- B --- C --- S


Where S is a single â€œsquashedâ€ commit.

âœ” Clean main
âœ” One commit per feature
âŒ Loses individual commits (D & E vanish)

3ï¸âƒ£ Rebase and Merge

GitHub replays (re-writes) the feature branch commits on top of main:

git rebase main feature


Result:

A --- B --- C --- D' --- E'


D' and E' are NEW commits (SHA changed).

âœ” Beautiful linear history
âŒ Rewrites history
âŒ Can break CI if not used carefully

ğŸ§¨ 3. Why pulling feature â†’ master is dangerous

You asked the BEST question here.

Doing:

git checkout main
git pull origin feature/login


is the worst possible action because:

âŒ 1. It bypasses ALL GitHub protection checks

No reviewer approvals

No CI checks

No conflict checks

No blocking rules

No required sign-offs

No Jira traceability

You bypass the entire safety system.

âŒ 2. Conflicts happen directly on main (disaster)

If thereâ€™s a conflict inside main,
you might break the main branch for everyone.

Where should conflicts be resolved?

âœ” In the feature branch,
âŒ NOT inside the main branch.

âŒ 3. Audit trail is destroyed

Direct pull leaves no PR record:

No "what changed"

No "who approved"

No "who reviewed"

No conversations

No traceability

For enterprise teams, this is unacceptable.

âŒ 4. CI/CD does NOT run automatically

So you may merge:

Failing tests

Security vulnerabilities

Incorrect logic

Syntax errors

â€¦ directly into main.

âŒ 5. You may accidentally fast-forward main

If your branch is ahead and you do:

git pull origin feature


You might make:

A --- B --- C --- D --- E   (feature becomes main)


Even if feature is HALF DONE!

âŒ 6. Direct pulls can corrupt history

Git might:

Rewrite commits

Create weird merges

Break bisect

Make revert harder

PR merges keep history consistent.

âŒ 7. Almost all companies LOCK the main branch

Rules in GitHub:

âœ” No pushes to main
âœ” PR required
âœ” CI required
âœ” Approvals required

So you cannot directly pull into master anyway.

ğŸ¯ TL;DR (Sumit Edition ğŸ˜„)
âœ” What happens inside GitHub when you create a PR?

GitHub runs:

diff

CI checks

protection rule checks

review system

conflict detection

metadata logging

final merge command

âœ” Merge types?

Merge Commit â†’ safe, full history

Squash â†’ clean, one commit

Rebase â†’ linear, rewrite history

âœ” Why not pull feature â†’ master?

It bypasses ALL safety, protection, review, CI, testing, and auditing â†’
You can break main and entire team loses productivity.